<#@ template language="C#" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.530
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#= this.Namespace #>
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using System.Threading;
    using System.Threading.Tasks;
    using C60.OrchestratorReference;
    using C60.OrchestratorReference.OrchestratorServiceReference;

    [System.Diagnostics.DebuggerStepThroughAttribute]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "4.0.0.0")]
    public class <#= this.ClassName #>
    {
        private static OrchestratorProvider orchestratorProvider;

        /// <summary>
        /// Initializes a new instance of the OrchestratorReference class.
        /// </summary>
        /// <param name="serviceUri">Overwrite the default server name/port from the original template</param>
        public <#= this.ClassName #>(Uri serviceUri)
        {
            orchestratorProvider = new OrchestratorProvider(serviceUri);
        }

        /// <summary>
        /// Initializes a new instance of the OrchestratorReference class that references the <#= this.OrchestratorWebServer #> server
        /// </summary>
        public <#= this.ClassName #>()
        {
            orchestratorProvider = new OrchestratorProvider(bool.Parse("<#= this.UseSSL #>"), "<#= this.OrchestratorWebServer #>", <#= this.Port #>);
        }

        /// <summary>
        /// Gets or sets the credential to use when accessing the orchestrator service.
        /// </summary>
        public ICredentials OrchestratorServiceCredentials 
        {
            get
            {
                return orchestratorProvider.OrchestratorContext.Credentials;
            }
            set
            {
                if (value != null)
                {
                    orchestratorProvider.OrchestratorContext.Credentials = value;
                }
            }
        }

        /// <summary>
        /// In case of using, on runtime, a different orchestrator server, this method enables replacing all the folders that start with specific prefix to a different one.
        /// </summary>
        /// <param name="originalPrefix">Original folder prefix</param>
        /// <param name="newPrefix">Replace with this prefix</param>
        public void AddReplaceFolderPrefix(string originalPrefix, string newPrefix)
        {
            orchestratorProvider.ReplaceFolderPrefix.Add(originalPrefix, newPrefix);
        }

        /// <summary>
        /// Returns an OrchestratorContext object for the current orchestrator web services
        /// </summary>
        /// <returns>New OrchestratorContext</returns>
        public OrchestratorContext CreateOrchestratorContext()
        {
            return 	orchestratorProvider.CreateOrchestratorContext();
        }

        /// <summary>
        /// Wait till the job complete and return runbook’s out parameters.
        /// </summary>
        /// <param name="jobId">Job Guid that returned from the runbook’s executing method.</param>
        /// <returns>Name Value dictionary</returns>
        public Dictionary<string, string> GetJobResult(Guid jobId)
        {
            return orchestratorProvider.GetJobResult(jobId);
        }

        /// <summary>
        /// Wait till the job complete and return runbook’s out parameters.
        /// </summary>
        /// <param name="jobId"></param>
        /// <param name="delayBetweenResultCheckSeconds">Frequency of checking for job completion</param>
        /// <param name="timeoutSeconds">Timeout waiting for job completion</param>
        /// <param name="cancellationToken">Cancellation Token</param>
        /// <returns>Name Value dictionary</returns>
        public Dictionary<string, string> GetJobResult(Guid jobId, int delayBetweenResultCheckSeconds, int timeoutSeconds, CancellationToken cancellationToken)
        {
            return orchestratorProvider.GetJobResult(jobId, delayBetweenResultCheckSeconds, timeoutSeconds, cancellationToken);
        }
        
        /// <summary>
        /// Return Task that wait till the job complete.
        /// </summary>
        /// <param name="jobId">Job Guid that returned from the runbook’s executing method.</param>
        /// <returns>Task of Name Value dictionary</returns>
        public Task<Dictionary<string, string>> GetJobResultAsync(Guid jobId)
        {
            return orchestratorProvider.GetJobResultAsync(jobId);
        }

        /// <summary>
        /// Return Task that wait till the job complete.
        /// </summary>
        /// <param name="jobId">Job Guid that returned from the runbook’s executing method.</param>
        /// <param name="cancellationToken">Cancellation Token</param>
        /// <returns>Task of Name Value dictionary</returns>
        public Task<Dictionary<string, string>> GetJobResultAsync(Guid jobId, CancellationToken cancellationToken)
        {
            return orchestratorProvider.GetJobResultAsync(jobId, cancellationToken);
        }

        /// <summary>
        /// Return Task that wait till the job complete.
        /// </summary>
        /// <param name="jobId">Job Guid that returned from the runbook’s executing method.</param>
        /// <param name="delayBetweenResultCheckSeconds">Frequency of checking for job completion</param>
        /// <param name="timeoutSeconds">Timeout waiting for job completion</param>
        /// <param name="cancellationToken">Cancellation Token</param>
        /// <returns>Task of Name Value dictionary</returns>
        public Task<Dictionary<string, string>> GetJobResultAsync(Guid jobId, int delayBetweenResultCheckSeconds, int timeoutSeconds, CancellationToken cancellationToken)
        {
            return orchestratorProvider.GetJobResultAsync(jobId, delayBetweenResultCheckSeconds, timeoutSeconds, cancellationToken);
        }
<#
    this.WriteFolderClass();
#>
    }
}
